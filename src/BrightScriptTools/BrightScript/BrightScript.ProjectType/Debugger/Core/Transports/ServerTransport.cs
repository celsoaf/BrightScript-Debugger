using System;
using System.Diagnostics;
using System.IO;
using System.Text.RegularExpressions;
using System.Threading;

namespace BrightScript.Debugger.Core.Transports
{
    public class ServerTransport : PipeTransport, ISignalingTransport
    {
        private string _startPattern;
        public string _messagePrefix;
        private bool _started;

        public ManualResetEvent StartedEvent { get; }

        public ServerTransport(bool killOnClose, bool filterStderr = false, bool filterStdout = false)
            : base(killOnClose, filterStderr, filterStdout)
        {
            StartedEvent = new ManualResetEvent(false);
        }

        public override void InitStreams(LaunchOptions options, out StreamReader reader, out StreamWriter writer)
        {
            LocalLaunchOptions localOptions = (LocalLaunchOptions)options;
            string miDebuggerDir = System.IO.Path.GetDirectoryName(localOptions.MIDebuggerPath);

            Process proc = new Process();
            proc.StartInfo.FileName = localOptions.DebugServer;
            proc.StartInfo.Arguments = localOptions.DebugServerArgs;
            proc.StartInfo.WorkingDirectory = miDebuggerDir;
            _startPattern = localOptions.ServerStarted;
            _messagePrefix = Path.GetFileNameWithoutExtension(localOptions.DebugServer);

            InitProcess(proc, out reader, out writer);
        }

        protected override string FilterLine(string line)
        {
            if (!_started && Regex.IsMatch(line, _startPattern, RegexOptions.None, new TimeSpan(0, 0, 0, 0, 10) /* 10 ms */))
            {
                _started = true;
                StartedEvent.Set();
            }

            this.Callback.LogText(_messagePrefix + ": " + line);   // log to debug output
            return null;
        }

        protected override string GetThreadName()
        {
            return "MI.ServerTransport";
        }
    }
}